
ram.elf:     file format elf32-littlearm


Disassembly of section .startup:

40000000 <_vectors>:
40000000:	e59ff018 	ldr	pc, [pc, #24]	; 40000020 <ResetAddr>
40000004:	e59ff018 	ldr	pc, [pc, #24]	; 40000024 <UndefAddr>
40000008:	e59ff018 	ldr	pc, [pc, #24]	; 40000028 <SWIAddr>
4000000c:	e59ff018 	ldr	pc, [pc, #24]	; 4000002c <PAbtAddr>
40000010:	e59ff018 	ldr	pc, [pc, #24]	; 40000030 <DAbtAddr>
40000014:	b9205f80 	.word	0xb9205f80
40000018:	e51ffff0 	ldr	pc, [pc, #-4080]	; 3ffff030 <__IRQ_STACK_SIZE__+0x3fffee30>
4000001c:	e59ff018 	ldr	pc, [pc, #24]	; 4000003c <FIQAddr>

40000020 <ResetAddr>:
40000020:	40000040 	.word	0x40000040

40000024 <UndefAddr>:
40000024:	4000205c 	.word	0x4000205c

40000028 <SWIAddr>:
40000028:	40002060 	.word	0x40002060

4000002c <PAbtAddr>:
4000002c:	40002064 	.word	0x40002064

40000030 <DAbtAddr>:
40000030:	40002068 	.word	0x40002068
	...

4000003c <FIQAddr>:
4000003c:	40002070 	.word	0x40002070

40000040 <_start>:
40000040:	e59f0094 	ldr	r0, [pc, #148]	; 400000dc <end_set_loop+0x18>
40000044:	e321f0d1 	msr	CPSR_c, #209	; 0xd1
40000048:	e1a0d000 	mov	sp, r0
4000004c:	e240000c 	sub	r0, r0, #12	; 0xc
40000050:	e321f0d2 	msr	CPSR_c, #210	; 0xd2
40000054:	e1a0d000 	mov	sp, r0
40000058:	e2400c02 	sub	r0, r0, #512	; 0x200
4000005c:	e321f0d3 	msr	CPSR_c, #211	; 0xd3
40000060:	e1a0d000 	mov	sp, r0
40000064:	e2400004 	sub	r0, r0, #4	; 0x4
40000068:	e321f0d7 	msr	CPSR_c, #215	; 0xd7
4000006c:	e1a0d000 	mov	sp, r0
40000070:	e2400004 	sub	r0, r0, #4	; 0x4
40000074:	e321f0db 	msr	CPSR_c, #219	; 0xdb
40000078:	e1a0d000 	mov	sp, r0
4000007c:	e2400004 	sub	r0, r0, #4	; 0x4
40000080:	e321f0df 	msr	CPSR_c, #223	; 0xdf
40000084:	e1a0d000 	mov	sp, r0
40000088:	e59f1050 	ldr	r1, [pc, #80]	; 400000e0 <end_set_loop+0x1c>
4000008c:	e59f2050 	ldr	r2, [pc, #80]	; 400000e4 <end_set_loop+0x20>
40000090:	e3a03000 	mov	r3, #0	; 0x0

40000094 <bss_clear_loop>:
40000094:	e1510002 	cmp	r1, r2
40000098:	14813004 	strne	r3, [r1], #4
4000009c:	1afffffc 	bne	40000094 <bss_clear_loop>
400000a0:	e59f1040 	ldr	r1, [pc, #64]	; 400000e8 <end_set_loop+0x24>
400000a4:	e59f2040 	ldr	r2, [pc, #64]	; 400000ec <end_set_loop+0x28>
400000a8:	e59f3040 	ldr	r3, [pc, #64]	; 400000f0 <end_set_loop+0x2c>
400000ac:	e1510002 	cmp	r1, r2
400000b0:	0a000003 	beq	400000c4 <end_set_loop>

400000b4 <set_loop>:
400000b4:	e1510003 	cmp	r1, r3
400000b8:	14924004 	ldrne	r4, [r2], #4
400000bc:	14814004 	strne	r4, [r1], #4
400000c0:	1afffffb 	bne	400000b4 <set_loop>

400000c4 <end_set_loop>:
400000c4:	e59fa028 	ldr	sl, [pc, #40]	; 400000f4 <end_set_loop+0x30>
400000c8:	e1a0e00f 	mov	lr, pc
400000cc:	e12fff1a 	bx	sl
400000d0:	e59fa020 	ldr	sl, [pc, #32]	; 400000f8 <end_set_loop+0x34>
400000d4:	e1a0e00f 	mov	lr, pc
400000d8:	e12fff1a 	bx	sl
400000dc:	4000205c 	.word	0x4000205c
400000e0:	4000104c 	.word	0x4000104c
400000e4:	4000105c 	.word	0x4000105c
400000e8:	4000104c 	.word	0x4000104c
400000ec:	4000104c 	.word	0x4000104c
400000f0:	4000104c 	.word	0x4000104c
400000f4:	400000fc 	.word	0x400000fc
400000f8:	40000fcc 	.word	0x40000fcc

Disassembly of section .text:

400000fc <StartOsc>:
#include  "startosc.h"
void StartOsc(void) {
400000fc:	e1a0c00d 	mov	ip, sp
40000100:	e92dd800 	push	{fp, ip, lr, pc}
40000104:	e24cb004 	sub	fp, ip, #4	; 0x4
  
    pPLL->CONFIGURATION =__PLL_P_VALUE__ | __PLL_M_VALUE__;
40000108:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
4000010c:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000110:	e2833080 	add	r3, r3, #128	; 0x80
40000114:	e3a02023 	mov	r2, #35	; 0x23
40000118:	e5c32004 	strb	r2, [r3, #4]
    PLL_FEED();
4000011c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000120:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000124:	e2833080 	add	r3, r3, #128	; 0x80
40000128:	e3e02055 	mvn	r2, #85	; 0x55
4000012c:	e5c3200c 	strb	r2, [r3, #12]
40000130:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000134:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000138:	e2833080 	add	r3, r3, #128	; 0x80
4000013c:	e3a02055 	mov	r2, #85	; 0x55
40000140:	e5c3200c 	strb	r2, [r3, #12]
    
    pPLL->CONTROL = __PLL_CONTROL_ON_DISCONNECTED__;
40000144:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000148:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
4000014c:	e2833080 	add	r3, r3, #128	; 0x80
40000150:	e3a02001 	mov	r2, #1	; 0x1
40000154:	e5c32000 	strb	r2, [r3]
    PLL_FEED();
40000158:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
4000015c:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000160:	e2833080 	add	r3, r3, #128	; 0x80
40000164:	e3e02055 	mvn	r2, #85	; 0x55
40000168:	e5c3200c 	strb	r2, [r3, #12]
4000016c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000170:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000174:	e2833080 	add	r3, r3, #128	; 0x80
40000178:	e3a02055 	mov	r2, #85	; 0x55
4000017c:	e5c3200c 	strb	r2, [r3, #12]

    while (!(pPLL->STATUS & __PLLSTAT_PLOCK_MASK__));
40000180:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000184:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000188:	e2833080 	add	r3, r3, #128	; 0x80
4000018c:	e1d330b8 	ldrh	r3, [r3, #8]
40000190:	e2033b01 	and	r3, r3, #1024	; 0x400
40000194:	e3530000 	cmp	r3, #0	; 0x0
40000198:	0afffff8 	beq	40000180 <StartOsc+0x84>

    pPLL->CONTROL = __PLL_CONTROL_OFF_CONNECTED__;
4000019c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400001a0:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400001a4:	e2833080 	add	r3, r3, #128	; 0x80
400001a8:	e3a02003 	mov	r2, #3	; 0x3
400001ac:	e5c32000 	strb	r2, [r3]
    
    PLL_FEED();
400001b0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400001b4:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400001b8:	e2833080 	add	r3, r3, #128	; 0x80
400001bc:	e3e02055 	mvn	r2, #85	; 0x55
400001c0:	e5c3200c 	strb	r2, [r3, #12]
400001c4:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400001c8:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400001cc:	e2833080 	add	r3, r3, #128	; 0x80
400001d0:	e3a02055 	mov	r2, #85	; 0x55
400001d4:	e5c3200c 	strb	r2, [r3, #12]
     
    pMAM->CONTROL_REGISTER = __MAM_FULLY_ENABLE__;
400001d8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400001dc:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400001e0:	e3a02002 	mov	r2, #2	; 0x2
400001e4:	e5832000 	str	r2, [r3]
     
    pMAM->TIMING = __MAMTIM_FETCH_3_CLOCK__; //according to Table 35: Suggestions for MAM timing selection 
400001e8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400001ec:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
400001f0:	e3a02003 	mov	r2, #3	; 0x3
400001f4:	e5832004 	str	r2, [r3, #4]
    
    pAPBDIV->APBDIV = __APBDIV_CLOCK_EQUAL_CLOCK__;
400001f8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400001fc:	e283397f 	add	r3, r3, #2080768	; 0x1fc000
40000200:	e2833c01 	add	r3, r3, #256	; 0x100
40000204:	e3a02001 	mov	r2, #1	; 0x1
40000208:	e5832000 	str	r2, [r3]
}
4000020c:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000210:	e89d6800 	ldm	sp, {fp, sp, lr}
40000214:	e12fff1e 	bx	lr

40000218 <timer_init>:
 * 44236800
 * 58982400     <--- Clock choosed (PCLCK = CCLKC)
* */

//PR (Prescale Register) contains the number of MCU clocks (PCLK) required to increment the Timer Counter (TC) value.
void timer_init(pLPC_TIMER timer, U32 countNbr){
40000218:	e1a0c00d 	mov	ip, sp
4000021c:	e92dd800 	push	{fp, ip, lr, pc}
40000220:	e24cb004 	sub	fp, ip, #4	; 0x4
40000224:	e24dd008 	sub	sp, sp, #8	; 0x8
40000228:	e50b0010 	str	r0, [fp, #-16]
4000022c:	e50b1014 	str	r1, [fp, #-20]
  timer->TCR    = __TCR_DISABLE__|__TCR_RESET_ENABLE__;
40000230:	e51b2010 	ldr	r2, [fp, #-16]
40000234:	e3a03002 	mov	r3, #2	; 0x2
40000238:	e5823004 	str	r3, [r2, #4]
  timer->CTCR   = __CTCR_MODE_0__;
4000023c:	e51b2010 	ldr	r2, [fp, #-16]
40000240:	e3a03000 	mov	r3, #0	; 0x0
40000244:	e5823070 	str	r3, [r2, #112]
  timer->PR     = countNbr;                           
40000248:	e51b2014 	ldr	r2, [fp, #-20]
4000024c:	e51b3010 	ldr	r3, [fp, #-16]
40000250:	e583200c 	str	r2, [r3, #12]
  timer->TCR    = __TCR_ENABLE__|__TCR_RESET_DISABLE__; 
40000254:	e51b2010 	ldr	r2, [fp, #-16]
40000258:	e3a03001 	mov	r3, #1	; 0x1
4000025c:	e5823004 	str	r3, [r2, #4]
}
40000260:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000264:	e89d6800 	ldm	sp, {fp, sp, lr}
40000268:	e12fff1e 	bx	lr

4000026c <timer_delay>:
//PC (Prescale Counter) contains the current prescale counter value. 
//When this value equals the Prescale Register (PR), the Timer (TC) value is incremented.
void timer_delay(pLPC_TIMER timer, U32 elapse){
4000026c:	e1a0c00d 	mov	ip, sp
40000270:	e92dd800 	push	{fp, ip, lr, pc}
40000274:	e24cb004 	sub	fp, ip, #4	; 0x4
40000278:	e24dd010 	sub	sp, sp, #16	; 0x10
4000027c:	e50b0018 	str	r0, [fp, #-24]
40000280:	e50b101c 	str	r1, [fp, #-28]
    U32 time;
    timer->PC = 0;                          
40000284:	e51b2018 	ldr	r2, [fp, #-24]
40000288:	e3a03000 	mov	r3, #0	; 0x0
4000028c:	e5823010 	str	r3, [r2, #16]
    time = timer_elapsed(timer,0);
40000290:	e51b3018 	ldr	r3, [fp, #-24]
40000294:	e5933008 	ldr	r3, [r3, #8]
40000298:	e50b3010 	str	r3, [fp, #-16]
    while(timer_elapsed(timer,time)<= elapse);
4000029c:	e51b3018 	ldr	r3, [fp, #-24]
400002a0:	e5932008 	ldr	r2, [r3, #8]
400002a4:	e51b3010 	ldr	r3, [fp, #-16]
400002a8:	e0632002 	rsb	r2, r3, r2
400002ac:	e51b301c 	ldr	r3, [fp, #-28]
400002b0:	e1520003 	cmp	r2, r3
400002b4:	9afffff8 	bls	4000029c <timer_delay+0x30>
}
400002b8:	e24bd00c 	sub	sp, fp, #12	; 0xc
400002bc:	e89d6800 	ldm	sp, {fp, sp, lr}
400002c0:	e12fff1e 	bx	lr

400002c4 <gpio_PINSEL0>:
 * 10 Second alternate function 
 * 11 Third alternate function 
 * */

/*The PINSEL0 register controls the functions of the pins 0-15*/
static void gpio_PINSEL0(U32 mask){ 
400002c4:	e1a0c00d 	mov	ip, sp
400002c8:	e92dd800 	push	{fp, ip, lr, pc}
400002cc:	e24cb004 	sub	fp, ip, #4	; 0x4
400002d0:	e24dd008 	sub	sp, sp, #8	; 0x8
400002d4:	e50b0010 	str	r0, [fp, #-16]
 __PINSEL0__ &= ~mask; 
400002d8:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
400002dc:	e282290b 	add	r2, r2, #180224	; 0x2c000
400002e0:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400002e4:	e283390b 	add	r3, r3, #180224	; 0x2c000
400002e8:	e5931000 	ldr	r1, [r3]
400002ec:	e51b3010 	ldr	r3, [fp, #-16]
400002f0:	e1e03003 	mvn	r3, r3
400002f4:	e0013003 	and	r3, r1, r3
400002f8:	e5823000 	str	r3, [r2]
}
400002fc:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000300:	e89d6800 	ldm	sp, {fp, sp, lr}
40000304:	e12fff1e 	bx	lr

40000308 <gpio_PINSEL1>:

/*The PINSEL1 register controls the functions of the pins 16-31*/
static void gpio_PINSEL1(U32 mask){   
40000308:	e1a0c00d 	mov	ip, sp
4000030c:	e92dd800 	push	{fp, ip, lr, pc}
40000310:	e24cb004 	sub	fp, ip, #4	; 0x4
40000314:	e24dd008 	sub	sp, sp, #8	; 0x8
40000318:	e50b0010 	str	r0, [fp, #-16]
  __PINSEL1__ &= ~mask;
4000031c:	e3a0224e 	mov	r2, #-536870908	; 0xe0000004
40000320:	e282290b 	add	r2, r2, #180224	; 0x2c000
40000324:	e3a0324e 	mov	r3, #-536870908	; 0xe0000004
40000328:	e283390b 	add	r3, r3, #180224	; 0x2c000
4000032c:	e5931000 	ldr	r1, [r3]
40000330:	e51b3010 	ldr	r3, [fp, #-16]
40000334:	e1e03003 	mvn	r3, r3
40000338:	e0013003 	and	r3, r1, r3
4000033c:	e5823000 	str	r3, [r2]
}
40000340:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000344:	e89d6800 	ldm	sp, {fp, sp, lr}
40000348:	e12fff1e 	bx	lr

4000034c <gpio_init>:

void gpio_init(U32 pinsel0_mask,U32 pinsel1_mask){
4000034c:	e1a0c00d 	mov	ip, sp
40000350:	e92dd800 	push	{fp, ip, lr, pc}
40000354:	e24cb004 	sub	fp, ip, #4	; 0x4
40000358:	e24dd008 	sub	sp, sp, #8	; 0x8
4000035c:	e50b0010 	str	r0, [fp, #-16]
40000360:	e50b1014 	str	r1, [fp, #-20]
  gpio_PINSEL0(pinsel0_mask);
40000364:	e51b3010 	ldr	r3, [fp, #-16]
40000368:	e1a00003 	mov	r0, r3
4000036c:	ebffffd4 	bl	400002c4 <gpio_PINSEL0>
  gpio_PINSEL1(pinsel1_mask);
40000370:	e51b3014 	ldr	r3, [fp, #-20]
40000374:	e1a00003 	mov	r0, r3
40000378:	ebffffe2 	bl	40000308 <gpio_PINSEL1>
} 
4000037c:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000380:	e89d6800 	ldm	sp, {fp, sp, lr}
40000384:	e12fff1e 	bx	lr

40000388 <gpio_write>:

void gpio_write(U32 mask, U32 value){
40000388:	e1a0c00d 	mov	ip, sp
4000038c:	e92dd800 	push	{fp, ip, lr, pc}
40000390:	e24cb004 	sub	fp, ip, #4	; 0x4
40000394:	e24dd008 	sub	sp, sp, #8	; 0x8
40000398:	e50b0010 	str	r0, [fp, #-16]
4000039c:	e50b1014 	str	r1, [fp, #-20]
  pGPIO->IOCLR |= mask ;
400003a0:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
400003a4:	e282290a 	add	r2, r2, #163840	; 0x28000
400003a8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400003ac:	e283390a 	add	r3, r3, #163840	; 0x28000
400003b0:	e593100c 	ldr	r1, [r3, #12]
400003b4:	e51b3010 	ldr	r3, [fp, #-16]
400003b8:	e1813003 	orr	r3, r1, r3
400003bc:	e582300c 	str	r3, [r2, #12]
  pGPIO->IOSET |= mask & value;    
400003c0:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
400003c4:	e281190a 	add	r1, r1, #163840	; 0x28000
400003c8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400003cc:	e283390a 	add	r3, r3, #163840	; 0x28000
400003d0:	e5930004 	ldr	r0, [r3, #4]
400003d4:	e51b2010 	ldr	r2, [fp, #-16]
400003d8:	e51b3014 	ldr	r3, [fp, #-20]
400003dc:	e0023003 	and	r3, r2, r3
400003e0:	e1803003 	orr	r3, r0, r3
400003e4:	e5813004 	str	r3, [r1, #4]
}
400003e8:	e24bd00c 	sub	sp, fp, #12	; 0xc
400003ec:	e89d6800 	ldm	sp, {fp, sp, lr}
400003f0:	e12fff1e 	bx	lr

400003f4 <gpio_set_direction>:
 *Table 62. (Page 72)
 * GPIO port 0 Direction register (IO0DIR - address 0xE002 8008) bit description
 * 0 Controlled pin is input.
 * 1 Controlled pin is output.
 * */
void gpio_set_direction(U32 mask, U8 direction){
400003f4:	e1a0c00d 	mov	ip, sp
400003f8:	e92dd800 	push	{fp, ip, lr, pc}
400003fc:	e24cb004 	sub	fp, ip, #4	; 0x4
40000400:	e24dd008 	sub	sp, sp, #8	; 0x8
40000404:	e50b0010 	str	r0, [fp, #-16]
40000408:	e1a03001 	mov	r3, r1
4000040c:	e54b3011 	strb	r3, [fp, #-17]
  if (direction)
40000410:	e55b3011 	ldrb	r3, [fp, #-17]
40000414:	e3530000 	cmp	r3, #0	; 0x0
40000418:	0a000008 	beq	40000440 <gpio_set_direction+0x4c>
    pGPIO->IODIR |= mask;
4000041c:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
40000420:	e282290a 	add	r2, r2, #163840	; 0x28000
40000424:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000428:	e283390a 	add	r3, r3, #163840	; 0x28000
4000042c:	e5931008 	ldr	r1, [r3, #8]
40000430:	e51b3010 	ldr	r3, [fp, #-16]
40000434:	e1813003 	orr	r3, r1, r3
40000438:	e5823008 	str	r3, [r2, #8]
4000043c:	ea000008 	b	40000464 <gpio_set_direction+0x70>
  else
    pGPIO->IODIR &= ~mask;
40000440:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
40000444:	e282290a 	add	r2, r2, #163840	; 0x28000
40000448:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
4000044c:	e283390a 	add	r3, r3, #163840	; 0x28000
40000450:	e5931008 	ldr	r1, [r3, #8]
40000454:	e51b3010 	ldr	r3, [fp, #-16]
40000458:	e1e03003 	mvn	r3, r3
4000045c:	e0013003 	and	r3, r1, r3
40000460:	e5823008 	str	r3, [r2, #8]
}
40000464:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000468:	e89d6800 	ldm	sp, {fp, sp, lr}
4000046c:	e12fff1e 	bx	lr

40000470 <gpio_set>:
void gpio_set(U32 mask){
40000470:	e1a0c00d 	mov	ip, sp
40000474:	e92dd800 	push	{fp, ip, lr, pc}
40000478:	e24cb004 	sub	fp, ip, #4	; 0x4
4000047c:	e24dd008 	sub	sp, sp, #8	; 0x8
40000480:	e50b0010 	str	r0, [fp, #-16]
  pGPIO->IOSET |= mask;
40000484:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
40000488:	e282290a 	add	r2, r2, #163840	; 0x28000
4000048c:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000490:	e283390a 	add	r3, r3, #163840	; 0x28000
40000494:	e5931004 	ldr	r1, [r3, #4]
40000498:	e51b3010 	ldr	r3, [fp, #-16]
4000049c:	e1813003 	orr	r3, r1, r3
400004a0:	e5823004 	str	r3, [r2, #4]
}
400004a4:	e24bd00c 	sub	sp, fp, #12	; 0xc
400004a8:	e89d6800 	ldm	sp, {fp, sp, lr}
400004ac:	e12fff1e 	bx	lr

400004b0 <gpio_clear>:
void gpio_clear(U32 mask){
400004b0:	e1a0c00d 	mov	ip, sp
400004b4:	e92dd800 	push	{fp, ip, lr, pc}
400004b8:	e24cb004 	sub	fp, ip, #4	; 0x4
400004bc:	e24dd008 	sub	sp, sp, #8	; 0x8
400004c0:	e50b0010 	str	r0, [fp, #-16]
  pGPIO->IOCLR |= mask ;
400004c4:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
400004c8:	e282290a 	add	r2, r2, #163840	; 0x28000
400004cc:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
400004d0:	e283390a 	add	r3, r3, #163840	; 0x28000
400004d4:	e593100c 	ldr	r1, [r3, #12]
400004d8:	e51b3010 	ldr	r3, [fp, #-16]
400004dc:	e1813003 	orr	r3, r1, r3
400004e0:	e582300c 	str	r3, [r2, #12]
}
400004e4:	e24bd00c 	sub	sp, fp, #12	; 0xc
400004e8:	e89d6800 	ldm	sp, {fp, sp, lr}
400004ec:	e12fff1e 	bx	lr

400004f0 <gpio_read>:

U32 gpio_read(U32 mask){
400004f0:	e1a0c00d 	mov	ip, sp
400004f4:	e92dd800 	push	{fp, ip, lr, pc}
400004f8:	e24cb004 	sub	fp, ip, #4	; 0x4
400004fc:	e24dd008 	sub	sp, sp, #8	; 0x8
40000500:	e50b0010 	str	r0, [fp, #-16]
    return  pGPIO->IOPIN & mask;
40000504:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
40000508:	e283390a 	add	r3, r3, #163840	; 0x28000
4000050c:	e5932000 	ldr	r2, [r3]
40000510:	e51b3010 	ldr	r3, [fp, #-16]
40000514:	e0023003 	and	r3, r2, r3
}
40000518:	e1a00003 	mov	r0, r3
4000051c:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000520:	e89d6800 	ldm	sp, {fp, sp, lr}
40000524:	e12fff1e 	bx	lr

40000528 <Wstrlen>:


U8 value = 0;
U8 isCentered = 0;
pLPC_TIMER ptimer;
inline U32 Wstrlen(const Pbyte str){
40000528:	e1a0c00d 	mov	ip, sp
4000052c:	e92dd800 	push	{fp, ip, lr, pc}
40000530:	e24cb004 	sub	fp, ip, #4	; 0x4
40000534:	e24dd008 	sub	sp, sp, #8	; 0x8
40000538:	e50b0010 	str	r0, [fp, #-16]
  register Pbyte p;

	for (p=str ; *p ; p++);
4000053c:	e51b2010 	ldr	r2, [fp, #-16]
40000540:	e50b2014 	str	r2, [fp, #-20]
40000544:	ea000002 	b	40000554 <Wstrlen+0x2c>
40000548:	e51b3014 	ldr	r3, [fp, #-20]
4000054c:	e2833001 	add	r3, r3, #1	; 0x1
40000550:	e50b3014 	str	r3, [fp, #-20]
40000554:	e51b2014 	ldr	r2, [fp, #-20]
40000558:	e5d23000 	ldrb	r3, [r2]
4000055c:	e20330ff 	and	r3, r3, #255	; 0xff
40000560:	e3530000 	cmp	r3, #0	; 0x0
40000564:	1afffff7 	bne	40000548 <Wstrlen+0x20>

	return p - str;
40000568:	e51b2014 	ldr	r2, [fp, #-20]
4000056c:	e51b3010 	ldr	r3, [fp, #-16]
40000570:	e0633002 	rsb	r3, r3, r2
}
40000574:	e1a00003 	mov	r0, r3
40000578:	e24bd00c 	sub	sp, fp, #12	; 0xc
4000057c:	e89d6800 	ldm	sp, {fp, sp, lr}
40000580:	e12fff1e 	bx	lr

40000584 <LCD_write>:

void LCD_write(U32  byte){
40000584:	e1a0c00d 	mov	ip, sp
40000588:	e92dd800 	push	{fp, ip, lr, pc}
4000058c:	e24cb004 	sub	fp, ip, #4	; 0x4
40000590:	e24dd008 	sub	sp, sp, #8	; 0x8
40000594:	e50b0010 	str	r0, [fp, #-16]
  gpio_write(DATA_MASK,(byte<<LCD_GPIO_MASK_SHIFT)&DATA_MASK);
40000598:	e51b3010 	ldr	r3, [fp, #-16]
4000059c:	e1a03403 	lsl	r3, r3, #8
400005a0:	e2033c0f 	and	r3, r3, #3840	; 0xf00
400005a4:	e3a00c0f 	mov	r0, #3840	; 0xf00
400005a8:	e1a01003 	mov	r1, r3
400005ac:	ebffff75 	bl	40000388 <gpio_write>
}
400005b0:	e24bd00c 	sub	sp, fp, #12	; 0xc
400005b4:	e89d6800 	ldm	sp, {fp, sp, lr}
400005b8:	e12fff1e 	bx	lr

400005bc <processValue_nibble>:

static void processValue_nibble(U8 rs, U8 value){
400005bc:	e1a0c00d 	mov	ip, sp
400005c0:	e92dd800 	push	{fp, ip, lr, pc}
400005c4:	e24cb004 	sub	fp, ip, #4	; 0x4
400005c8:	e24dd008 	sub	sp, sp, #8	; 0x8
400005cc:	e1a03000 	mov	r3, r0
400005d0:	e1a02001 	mov	r2, r1
400005d4:	e54b300d 	strb	r3, [fp, #-13]
400005d8:	e1a03002 	mov	r3, r2
400005dc:	e54b300e 	strb	r3, [fp, #-14]
  gpio_set(ENABLE_MASK);
400005e0:	e3a00a02 	mov	r0, #8192	; 0x2000
400005e4:	ebffffa1 	bl	40000470 <gpio_set>
  LCD_write( value );
400005e8:	e55b300e 	ldrb	r3, [fp, #-14]
400005ec:	e1a00003 	mov	r0, r3
400005f0:	ebffffe3 	bl	40000584 <LCD_write>
  timer_sleep_miliseconds(ptimer,20);
400005f4:	e59f3024 	ldr	r3, [pc, #36]	; 40000620 <processValue_nibble+0x64>
400005f8:	e5933000 	ldr	r3, [r3]
400005fc:	e1a00003 	mov	r0, r3
40000600:	e3a01c4f 	mov	r1, #20224	; 0x4f00
40000604:	e2811060 	add	r1, r1, #96	; 0x60
40000608:	ebffff17 	bl	4000026c <timer_delay>
  gpio_clear(ENABLE_MASK);
4000060c:	e3a00a02 	mov	r0, #8192	; 0x2000
40000610:	ebffffa6 	bl	400004b0 <gpio_clear>
}
40000614:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000618:	e89d6800 	ldm	sp, {fp, sp, lr}
4000061c:	e12fff1e 	bx	lr
40000620:	40001058 	.word	0x40001058

40000624 <processValue>:
static void processValue(U8 rs, U8 value){
40000624:	e1a0c00d 	mov	ip, sp
40000628:	e92dd800 	push	{fp, ip, lr, pc}
4000062c:	e24cb004 	sub	fp, ip, #4	; 0x4
40000630:	e24dd008 	sub	sp, sp, #8	; 0x8
40000634:	e1a03000 	mov	r3, r0
40000638:	e1a02001 	mov	r2, r1
4000063c:	e54b300d 	strb	r3, [fp, #-13]
40000640:	e1a03002 	mov	r3, r2
40000644:	e54b300e 	strb	r3, [fp, #-14]
  processValue_nibble(rs,(((value) >> DATA_BITS_SHIFT)&CLEAN_MASK));
40000648:	e55b300e 	ldrb	r3, [fp, #-14]
4000064c:	e1a03223 	lsr	r3, r3, #4
40000650:	e20320ff 	and	r2, r3, #255	; 0xff
40000654:	e55b300d 	ldrb	r3, [fp, #-13]
40000658:	e1a00003 	mov	r0, r3
4000065c:	e1a01002 	mov	r1, r2
40000660:	ebffffd5 	bl	400005bc <processValue_nibble>
  timer_sleep_miliseconds(ptimer,20);
40000664:	e59f3034 	ldr	r3, [pc, #52]	; 400006a0 <processValue+0x7c>
40000668:	e5933000 	ldr	r3, [r3]
4000066c:	e1a00003 	mov	r0, r3
40000670:	e3a01c4f 	mov	r1, #20224	; 0x4f00
40000674:	e2811060 	add	r1, r1, #96	; 0x60
40000678:	ebfffefb 	bl	4000026c <timer_delay>
  processValue_nibble(rs,value&CLEAN_MASK);
4000067c:	e55b300e 	ldrb	r3, [fp, #-14]
40000680:	e203300f 	and	r3, r3, #15	; 0xf
40000684:	e55b200d 	ldrb	r2, [fp, #-13]
40000688:	e1a00002 	mov	r0, r2
4000068c:	e1a01003 	mov	r1, r3
40000690:	ebffffc9 	bl	400005bc <processValue_nibble>
 
}  
40000694:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000698:	e89d6800 	ldm	sp, {fp, sp, lr}
4000069c:	e12fff1e 	bx	lr
400006a0:	40001058 	.word	0x40001058

400006a4 <LCD_init>:

void LCD_init(pLPC_TIMER timer){
400006a4:	e1a0c00d 	mov	ip, sp
400006a8:	e92dd800 	push	{fp, ip, lr, pc}
400006ac:	e24cb004 	sub	fp, ip, #4	; 0x4
400006b0:	e24dd008 	sub	sp, sp, #8	; 0x8
400006b4:	e50b0010 	str	r0, [fp, #-16]
    //Pag51: Table 6. Interface Data Length : Four bits
    /* Begin inicialization */

    ptimer=timer;
400006b8:	e59f20e0 	ldr	r2, [pc, #224]	; 400007a0 <LCD_init+0xfc>
400006bc:	e51b3010 	ldr	r3, [fp, #-16]
400006c0:	e5823000 	str	r3, [r2]

  gpio_set_direction(LCD_GPIO_MASK,GPIO_OUT);
400006c4:	e3a00c3f 	mov	r0, #16128	; 0x3f00
400006c8:	e3a01001 	mov	r1, #1	; 0x1
400006cc:	ebffff48 	bl	400003f4 <gpio_set_direction>
  gpio_clear(RS_MASK);
400006d0:	e3a00a01 	mov	r0, #4096	; 0x1000
400006d4:	ebffff75 	bl	400004b0 <gpio_clear>
  gpio_clear(ENABLE_MASK);
400006d8:	e3a00a02 	mov	r0, #8192	; 0x2000
400006dc:	ebffff73 	bl	400004b0 <gpio_clear>
  
  
    timer_sleep_miliseconds(timer,46);          //Wait for 45 ms or more after VDD
400006e0:	e51b0010 	ldr	r0, [fp, #-16]
400006e4:	e3a01cb6 	mov	r1, #46592	; 0xb600
400006e8:	e2811090 	add	r1, r1, #144	; 0x90
400006ec:	ebfffede 	bl	4000026c <timer_delay>
    processValue_nibble(0,0x3);    
400006f0:	e3a00000 	mov	r0, #0	; 0x0
400006f4:	e3a01003 	mov	r1, #3	; 0x3
400006f8:	ebffffaf 	bl	400005bc <processValue_nibble>
    timer_sleep_miliseconds(timer,5);           //Wait for 4,1 ms or more
400006fc:	e51b0010 	ldr	r0, [fp, #-16]
40000700:	e3a01d4f 	mov	r1, #5056	; 0x13c0
40000704:	e2811018 	add	r1, r1, #24	; 0x18
40000708:	ebfffed7 	bl	4000026c <timer_delay>
    processValue_nibble(0,0x3);    
4000070c:	e3a00000 	mov	r0, #0	; 0x0
40000710:	e3a01003 	mov	r1, #3	; 0x3
40000714:	ebffffa8 	bl	400005bc <processValue_nibble>
    timer_sleep_microseconds(timer,110);           //Wait for 100 μs or more
40000718:	e51b0010 	ldr	r0, [fp, #-16]
4000071c:	e3a0106e 	mov	r1, #110	; 0x6e
40000720:	ebfffed1 	bl	4000026c <timer_delay>
    processValue_nibble(0,0x3);    
40000724:	e3a00000 	mov	r0, #0	; 0x0
40000728:	e3a01003 	mov	r1, #3	; 0x3
4000072c:	ebffffa2 	bl	400005bc <processValue_nibble>

    

    processValue_nibble(0,0x2);    //Functon set (interface data length : 4 bits)
40000730:	e3a00000 	mov	r0, #0	; 0x0
40000734:	e3a01002 	mov	r1, #2	; 0x2
40000738:	ebffff9f 	bl	400005bc <processValue_nibble>

    timer_sleep_miliseconds(timer,5);
4000073c:	e51b0010 	ldr	r0, [fp, #-16]
40000740:	e3a01d4f 	mov	r1, #5056	; 0x13c0
40000744:	e2811018 	add	r1, r1, #24	; 0x18
40000748:	ebfffec7 	bl	4000026c <timer_delay>
    
    processValue(0,0x28);    //Function Set (0x28) -> Set Duty
4000074c:	e3a00000 	mov	r0, #0	; 0x0
40000750:	e3a01028 	mov	r1, #40	; 0x28
40000754:	ebffffb2 	bl	40000624 <processValue>
    processValue(0,0x08);    //Display OFF (0x08)
40000758:	e3a00000 	mov	r0, #0	; 0x0
4000075c:	e3a01008 	mov	r1, #8	; 0x8
40000760:	ebffffaf 	bl	40000624 <processValue>
    processValue(0,0x01);    //Display Clear (0x01)
40000764:	e3a00000 	mov	r0, #0	; 0x0
40000768:	e3a01001 	mov	r1, #1	; 0x1
4000076c:	ebffffac 	bl	40000624 <processValue>
    processValue(0,0x07);    //Entry Mode Set (0x07) -> Set Increment, Display shift
40000770:	e3a00000 	mov	r0, #0	; 0x0
40000774:	e3a01007 	mov	r1, #7	; 0x7
40000778:	ebffffa9 	bl	40000624 <processValue>
    
    /* Entry Mode Set */
    processValue(0,ENTRY_SET_MASK);      //Entry Mode 
4000077c:	e3a00000 	mov	r0, #0	; 0x0
40000780:	e3a01006 	mov	r1, #6	; 0x6
40000784:	ebffffa6 	bl	40000624 <processValue>
    
    /* Activate the Display */
    processValue(0,DISPLAY_ON_MASK);    //Display  
40000788:	e3a00000 	mov	r0, #0	; 0x0
4000078c:	e3a0100e 	mov	r1, #14	; 0xe
40000790:	ebffffa3 	bl	40000624 <processValue>
    //processValue(0,CURSOR_ON_MASK);    //Cursor
}
40000794:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000798:	e89d6800 	ldm	sp, {fp, sp, lr}
4000079c:	e12fff1e 	bx	lr
400007a0:	40001058 	.word	0x40001058

400007a4 <entryModeSet>:


/**
 * Activa o modo de entrada de dados
 */
void entryModeSet() {processValue(0,ENTRY_SET_MASK);}
400007a4:	e1a0c00d 	mov	ip, sp
400007a8:	e92dd800 	push	{fp, ip, lr, pc}
400007ac:	e24cb004 	sub	fp, ip, #4	; 0x4
400007b0:	e3a00000 	mov	r0, #0	; 0x0
400007b4:	e3a01006 	mov	r1, #6	; 0x6
400007b8:	ebffff99 	bl	40000624 <processValue>
400007bc:	e24bd00c 	sub	sp, fp, #12	; 0xc
400007c0:	e89d6800 	ldm	sp, {fp, sp, lr}
400007c4:	e12fff1e 	bx	lr

400007c8 <displayControlOn>:
  
/**
 * Activa o mostrador
 */
void displayControlOn() {processValue(0,DISPLAY_ON_MASK | CURSOR_ON_MASK);}
400007c8:	e1a0c00d 	mov	ip, sp
400007cc:	e92dd800 	push	{fp, ip, lr, pc}
400007d0:	e24cb004 	sub	fp, ip, #4	; 0x4
400007d4:	e3a00000 	mov	r0, #0	; 0x0
400007d8:	e3a0100e 	mov	r1, #14	; 0xe
400007dc:	ebffff90 	bl	40000624 <processValue>
400007e0:	e24bd00c 	sub	sp, fp, #12	; 0xc
400007e4:	e89d6800 	ldm	sp, {fp, sp, lr}
400007e8:	e12fff1e 	bx	lr

400007ec <displayControlOff>:
/**
 * Desactiva o mostrador
 */
void displayControlOff() {processValue(0,DISPLAY_OFF_MASK);}
400007ec:	e1a0c00d 	mov	ip, sp
400007f0:	e92dd800 	push	{fp, ip, lr, pc}
400007f4:	e24cb004 	sub	fp, ip, #4	; 0x4
400007f8:	e3a00000 	mov	r0, #0	; 0x0
400007fc:	e3a01008 	mov	r1, #8	; 0x8
40000800:	ebffff87 	bl	40000624 <processValue>
40000804:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000808:	e89d6800 	ldm	sp, {fp, sp, lr}
4000080c:	e12fff1e 	bx	lr

40000810 <blinkOff>:
/**
 * Desactiva o Blink
 */
void blinkOff() {processValue(0,DISPLAY_ON_MASK | BLINK_OFF_MASK);}
40000810:	e1a0c00d 	mov	ip, sp
40000814:	e92dd800 	push	{fp, ip, lr, pc}
40000818:	e24cb004 	sub	fp, ip, #4	; 0x4
4000081c:	e3a00000 	mov	r0, #0	; 0x0
40000820:	e3a0100e 	mov	r1, #14	; 0xe
40000824:	ebffff7e 	bl	40000624 <processValue>
40000828:	e24bd00c 	sub	sp, fp, #12	; 0xc
4000082c:	e89d6800 	ldm	sp, {fp, sp, lr}
40000830:	e12fff1e 	bx	lr

40000834 <clear>:

/**
 * Apaga todos os caracteres do display
 * */
void clear() {processValue(0,CLEAR_MASK);}
40000834:	e1a0c00d 	mov	ip, sp
40000838:	e92dd800 	push	{fp, ip, lr, pc}
4000083c:	e24cb004 	sub	fp, ip, #4	; 0x4
40000840:	e3a00000 	mov	r0, #0	; 0x0
40000844:	e3a01001 	mov	r1, #1	; 0x1
40000848:	ebffff75 	bl	40000624 <processValue>
4000084c:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000850:	e89d6800 	ldm	sp, {fp, sp, lr}
40000854:	e12fff1e 	bx	lr

40000858 <clearLine>:
/**
 * Apaga todos os caracteres de uma linha
 * */
void clearLine(U8 line) {
40000858:	e1a0c00d 	mov	ip, sp
4000085c:	e92dd800 	push	{fp, ip, lr, pc}
40000860:	e24cb004 	sub	fp, ip, #4	; 0x4
40000864:	e24dd008 	sub	sp, sp, #8	; 0x8
40000868:	e1a03000 	mov	r3, r0
4000086c:	e54b300d 	strb	r3, [fp, #-13]
  posCursor(line, 0);
40000870:	e55b300d 	ldrb	r3, [fp, #-13]
40000874:	e1a00003 	mov	r0, r3
40000878:	e3a01000 	mov	r1, #0	; 0x0
4000087c:	eb000012 	bl	400008cc <posCursor>
  register U8 i=0;
40000880:	e3a02000 	mov	r2, #0	; 0x0
40000884:	e50b2014 	str	r2, [fp, #-20]
40000888:	ea000005 	b	400008a4 <clearLine+0x4c>
  for (; i < 40; i++)
    writeChar(' ');
4000088c:	e3a00020 	mov	r0, #32	; 0x20
40000890:	eb000045 	bl	400009ac <writeChar>
 * Apaga todos os caracteres de uma linha
 * */
void clearLine(U8 line) {
  posCursor(line, 0);
  register U8 i=0;
  for (; i < 40; i++)
40000894:	e51b2014 	ldr	r2, [fp, #-20]
40000898:	e2823001 	add	r3, r2, #1	; 0x1
4000089c:	e20330ff 	and	r3, r3, #255	; 0xff
400008a0:	e50b3014 	str	r3, [fp, #-20]
400008a4:	e51b3014 	ldr	r3, [fp, #-20]
400008a8:	e3530027 	cmp	r3, #39	; 0x27
400008ac:	9afffff6 	bls	4000088c <clearLine+0x34>
    writeChar(' ');
  posCursor(line, 0);
400008b0:	e55b300d 	ldrb	r3, [fp, #-13]
400008b4:	e1a00003 	mov	r0, r3
400008b8:	e3a01000 	mov	r1, #0	; 0x0
400008bc:	eb000002 	bl	400008cc <posCursor>
}
400008c0:	e24bd00c 	sub	sp, fp, #12	; 0xc
400008c4:	e89d6800 	ldm	sp, {fp, sp, lr}
400008c8:	e12fff1e 	bx	lr

400008cc <posCursor>:

/**
 * 
 *  Posiciona o cursor na linha (0..1) e coluna (0..15) indicadas
 */
void posCursor(U8 line, U8 col) { processValue(0,ADDR_COUNTER_MASK | (0x40 * line + col));}
400008cc:	e1a0c00d 	mov	ip, sp
400008d0:	e92dd800 	push	{fp, ip, lr, pc}
400008d4:	e24cb004 	sub	fp, ip, #4	; 0x4
400008d8:	e24dd008 	sub	sp, sp, #8	; 0x8
400008dc:	e1a03000 	mov	r3, r0
400008e0:	e1a02001 	mov	r2, r1
400008e4:	e54b300d 	strb	r3, [fp, #-13]
400008e8:	e1a03002 	mov	r3, r2
400008ec:	e54b300e 	strb	r3, [fp, #-14]
400008f0:	e55b300d 	ldrb	r3, [fp, #-13]
400008f4:	e1a03303 	lsl	r3, r3, #6
400008f8:	e20320ff 	and	r2, r3, #255	; 0xff
400008fc:	e55b300e 	ldrb	r3, [fp, #-14]
40000900:	e0823003 	add	r3, r2, r3
40000904:	e20330ff 	and	r3, r3, #255	; 0xff
40000908:	e1e03c83 	mvn	r3, r3, lsl #25
4000090c:	e1e03ca3 	mvn	r3, r3, lsr #25
40000910:	e20330ff 	and	r3, r3, #255	; 0xff
40000914:	e20330ff 	and	r3, r3, #255	; 0xff
40000918:	e3a00000 	mov	r0, #0	; 0x0
4000091c:	e1a01003 	mov	r1, r3
40000920:	ebffff3f 	bl	40000624 <processValue>
40000924:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000928:	e89d6800 	ldm	sp, {fp, sp, lr}
4000092c:	e12fff1e 	bx	lr

40000930 <setCursor>:
 * Cursor/Blink Control Circuit The cursor/blink control circuit
 * generates the cursor or character blinking. The cursor or the
 * blinking will appear with the digit located at the display
 * data RAM (DDRAM) address set in the address counter (AC).
 */
void setCursor(U8 visible, U8 blinking) {
40000930:	e1a0c00d 	mov	ip, sp
40000934:	e92dd800 	push	{fp, ip, lr, pc}
40000938:	e24cb004 	sub	fp, ip, #4	; 0x4
4000093c:	e24dd010 	sub	sp, sp, #16	; 0x10
40000940:	e1a03000 	mov	r3, r0
40000944:	e1a02001 	mov	r2, r1
40000948:	e54b300d 	strb	r3, [fp, #-13]
4000094c:	e1a03002 	mov	r3, r2
40000950:	e54b300e 	strb	r3, [fp, #-14]
  processValue(0,(char) (visible ? CURSOR_ON_MASK | (blinking ? BLINK_ON_MASK : BLINK_OFF_MASK):(CURSOR_OFF_MASK | (blinking ? BLINK_ON_MASK : BLINK_OFF_MASK))));
40000954:	e55b300d 	ldrb	r3, [fp, #-13]
40000958:	e3530000 	cmp	r3, #0	; 0x0
4000095c:	0a00000a 	beq	4000098c <setCursor+0x5c>
40000960:	e55b300e 	ldrb	r3, [fp, #-14]
40000964:	e3530000 	cmp	r3, #0	; 0x0
40000968:	0a000002 	beq	40000978 <setCursor+0x48>
4000096c:	e3a0300b 	mov	r3, #11	; 0xb
40000970:	e50b3014 	str	r3, [fp, #-20]
40000974:	ea000001 	b	40000980 <setCursor+0x50>
40000978:	e3a0300a 	mov	r3, #10	; 0xa
4000097c:	e50b3014 	str	r3, [fp, #-20]
40000980:	e51b3014 	ldr	r3, [fp, #-20]
40000984:	e50b3018 	str	r3, [fp, #-24]
40000988:	ea000001 	b	40000994 <setCursor+0x64>
4000098c:	e3a0300b 	mov	r3, #11	; 0xb
40000990:	e50b3018 	str	r3, [fp, #-24]
40000994:	e3a00000 	mov	r0, #0	; 0x0
40000998:	e51b1018 	ldr	r1, [fp, #-24]
4000099c:	ebffff20 	bl	40000624 <processValue>
}
400009a0:	e24bd00c 	sub	sp, fp, #12	; 0xc
400009a4:	e89d6800 	ldm	sp, {fp, sp, lr}
400009a8:	e12fff1e 	bx	lr

400009ac <writeChar>:
/**
 * 
 * Escreve o caracter indicado no local do cursor e o cursor
 * avança para a proxima coluna
 */
void writeChar(U8 c) {processValue(1,c);}
400009ac:	e1a0c00d 	mov	ip, sp
400009b0:	e92dd800 	push	{fp, ip, lr, pc}
400009b4:	e24cb004 	sub	fp, ip, #4	; 0x4
400009b8:	e24dd008 	sub	sp, sp, #8	; 0x8
400009bc:	e1a03000 	mov	r3, r0
400009c0:	e54b300d 	strb	r3, [fp, #-13]
400009c4:	e55b300d 	ldrb	r3, [fp, #-13]
400009c8:	e3a00001 	mov	r0, #1	; 0x1
400009cc:	e1a01003 	mov	r1, r3
400009d0:	ebffff13 	bl	40000624 <processValue>
400009d4:	e24bd00c 	sub	sp, fp, #12	; 0xc
400009d8:	e89d6800 	ldm	sp, {fp, sp, lr}
400009dc:	e12fff1e 	bx	lr

400009e0 <writeString>:
/**
 * 
 * Escreve o texto indicado no local do cursor e o cursor avança
 * para a coluna seguinte
 */
void writeString(Pbyte txt) {
400009e0:	e1a0c00d 	mov	ip, sp
400009e4:	e92dd800 	push	{fp, ip, lr, pc}
400009e8:	e24cb004 	sub	fp, ip, #4	; 0x4
400009ec:	e24dd008 	sub	sp, sp, #8	; 0x8
400009f0:	e50b0010 	str	r0, [fp, #-16]
  gpio_set(RS_MASK);
400009f4:	e3a00a01 	mov	r0, #4096	; 0x1000
400009f8:	ebfffe9c 	bl	40000470 <gpio_set>
400009fc:	ea000008 	b	40000a24 <writeString+0x44>
  while(*txt){
      processValue(1,*txt);
40000a00:	e51b3010 	ldr	r3, [fp, #-16]
40000a04:	e5d33000 	ldrb	r3, [r3]
40000a08:	e20330ff 	and	r3, r3, #255	; 0xff
40000a0c:	e3a00001 	mov	r0, #1	; 0x1
40000a10:	e1a01003 	mov	r1, r3
40000a14:	ebffff02 	bl	40000624 <processValue>
      txt++;
40000a18:	e51b3010 	ldr	r3, [fp, #-16]
40000a1c:	e2833001 	add	r3, r3, #1	; 0x1
40000a20:	e50b3010 	str	r3, [fp, #-16]
 * Escreve o texto indicado no local do cursor e o cursor avança
 * para a coluna seguinte
 */
void writeString(Pbyte txt) {
  gpio_set(RS_MASK);
  while(*txt){
40000a24:	e51b3010 	ldr	r3, [fp, #-16]
40000a28:	e5d33000 	ldrb	r3, [r3]
40000a2c:	e20330ff 	and	r3, r3, #255	; 0xff
40000a30:	e3530000 	cmp	r3, #0	; 0x0
40000a34:	1afffff1 	bne	40000a00 <writeString+0x20>
      processValue(1,*txt);
      txt++;
  }
}
40000a38:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000a3c:	e89d6800 	ldm	sp, {fp, sp, lr}
40000a40:	e12fff1e 	bx	lr

40000a44 <writeLine>:
/**
 * Escreve o texto indicado na linha indicada (0 ou 1). O resto
 * da linha é texto fica centrado ou alinhado à
 * esquerda,dependendo da última chamada a SetCenter()
 */
void writeLine(U8 line, Pbyte txt) {
40000a44:	e1a0c00d 	mov	ip, sp
40000a48:	e92dd800 	push	{fp, ip, lr, pc}
40000a4c:	e24cb004 	sub	fp, ip, #4	; 0x4
40000a50:	e24dd010 	sub	sp, sp, #16	; 0x10
40000a54:	e1a03000 	mov	r3, r0
40000a58:	e50b101c 	str	r1, [fp, #-28]
40000a5c:	e54b3015 	strb	r3, [fp, #-21]
  int length = Wstrlen(txt);
40000a60:	e51b001c 	ldr	r0, [fp, #-28]
40000a64:	ebfffeaf 	bl	40000528 <Wstrlen>
40000a68:	e1a03000 	mov	r3, r0
40000a6c:	e50b3010 	str	r3, [fp, #-16]
  if (isCentered){
40000a70:	e59f304c 	ldr	r3, [pc, #76]	; 40000ac4 <writeLine+0x80>
40000a74:	e5d33000 	ldrb	r3, [r3]
40000a78:	e3530000 	cmp	r3, #0	; 0x0
40000a7c:	0a000005 	beq	40000a98 <writeLine+0x54>
    length =  (DISPLAY_SIZE_MASK - length) / 2;
40000a80:	e51b3010 	ldr	r3, [fp, #-16]
40000a84:	e2632010 	rsb	r2, r3, #16	; 0x10
40000a88:	e1a03fa2 	lsr	r3, r2, #31
40000a8c:	e0833002 	add	r3, r3, r2
40000a90:	e1a030c3 	asr	r3, r3, #1
40000a94:	e50b3010 	str	r3, [fp, #-16]
  }
  posCursor(line, (length));
40000a98:	e51b3010 	ldr	r3, [fp, #-16]
40000a9c:	e20320ff 	and	r2, r3, #255	; 0xff
40000aa0:	e55b3015 	ldrb	r3, [fp, #-21]
40000aa4:	e1a00003 	mov	r0, r3
40000aa8:	e1a01002 	mov	r1, r2
40000aac:	ebffff86 	bl	400008cc <posCursor>
  writeString(txt);
40000ab0:	e51b001c 	ldr	r0, [fp, #-28]
40000ab4:	ebffffc9 	bl	400009e0 <writeString>
}
40000ab8:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000abc:	e89d6800 	ldm	sp, {fp, sp, lr}
40000ac0:	e12fff1e 	bx	lr
40000ac4:	4000104d 	.word	0x4000104d

40000ac8 <setCenter>:

/**
 * Indica se o texto escrito com writeLine() nas chamadas
 * seguintes deve ou não ficar centrado na linha
 */
inline void setCenter(U8 value) {isCentered = value;}
40000ac8:	e1a0c00d 	mov	ip, sp
40000acc:	e92dd800 	push	{fp, ip, lr, pc}
40000ad0:	e24cb004 	sub	fp, ip, #4	; 0x4
40000ad4:	e24dd008 	sub	sp, sp, #8	; 0x8
40000ad8:	e1a03000 	mov	r3, r0
40000adc:	e54b300d 	strb	r3, [fp, #-13]
40000ae0:	e59f2010 	ldr	r2, [pc, #16]	; 40000af8 <setCenter+0x30>
40000ae4:	e55b300d 	ldrb	r3, [fp, #-13]
40000ae8:	e5c23000 	strb	r3, [r2]
40000aec:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000af0:	e89d6800 	ldm	sp, {fp, sp, lr}
40000af4:	e12fff1e 	bx	lr
40000af8:	4000104d 	.word	0x4000104d

40000afc <getPos>:
 * onde vai escrever.
 * x=Total de Caracteres do LCD (16) y=Total de Caracteres da String
 * se centrado pos=(x - y)/2 + (y - b) = (x - y + 2y - 2b)/2 = (x +
 * y -2b)/2 se não centrado pos= y - b
 */
static int getPos(Pbyte txt, U8 b) {
40000afc:	e1a0c00d 	mov	ip, sp
40000b00:	e92dd800 	push	{fp, ip, lr, pc}
40000b04:	e24cb004 	sub	fp, ip, #4	; 0x4
40000b08:	e24dd018 	sub	sp, sp, #24	; 0x18
40000b0c:	e50b0018 	str	r0, [fp, #-24]
40000b10:	e1a03001 	mov	r3, r1
40000b14:	e54b3019 	strb	r3, [fp, #-25]
  int length = Wstrlen(txt);
40000b18:	e51b0018 	ldr	r0, [fp, #-24]
40000b1c:	ebfffe81 	bl	40000528 <Wstrlen>
40000b20:	e1a03000 	mov	r3, r0
40000b24:	e50b3010 	str	r3, [fp, #-16]
  return (isCentered) ? (DISPLAY_SIZE_MASK + length - 2 * b) / 2 : (length - 3);
40000b28:	e59f3054 	ldr	r3, [pc, #84]	; 40000b84 <getPos+0x88>
40000b2c:	e5d33000 	ldrb	r3, [r3]
40000b30:	e3530000 	cmp	r3, #0	; 0x0
40000b34:	0a00000a 	beq	40000b64 <getPos+0x68>
40000b38:	e51b3010 	ldr	r3, [fp, #-16]
40000b3c:	e2832010 	add	r2, r3, #16	; 0x10
40000b40:	e55b3019 	ldrb	r3, [fp, #-25]
40000b44:	e1a03083 	lsl	r3, r3, #1
40000b48:	e2633000 	rsb	r3, r3, #0	; 0x0
40000b4c:	e0822003 	add	r2, r2, r3
40000b50:	e1a03fa2 	lsr	r3, r2, #31
40000b54:	e0833002 	add	r3, r3, r2
40000b58:	e1a030c3 	asr	r3, r3, #1
40000b5c:	e50b3020 	str	r3, [fp, #-32]
40000b60:	ea000002 	b	40000b70 <getPos+0x74>
40000b64:	e51b3010 	ldr	r3, [fp, #-16]
40000b68:	e2433003 	sub	r3, r3, #3	; 0x3
40000b6c:	e50b3020 	str	r3, [fp, #-32]
40000b70:	e51b3020 	ldr	r3, [fp, #-32]
}
40000b74:	e1a00003 	mov	r0, r3
40000b78:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000b7c:	e89d6800 	ldm	sp, {fp, sp, lr}
40000b80:	e12fff1e 	bx	lr
40000b84:	4000104d 	.word	0x4000104d

40000b88 <keyboard_init>:
 * No GPIO port's are defined yet, since the keyboard read may not be done yet.
 * 
 * @param[in]] timer: initialized timer structure
 * 
 * */
void keyboard_init(pLPC_TIMER timer){
40000b88:	e1a0c00d 	mov	ip, sp
40000b8c:	e92dd800 	push	{fp, ip, lr, pc}
40000b90:	e24cb004 	sub	fp, ip, #4	; 0x4
40000b94:	e24dd008 	sub	sp, sp, #8	; 0x8
40000b98:	e50b0010 	str	r0, [fp, #-16]
    //gpio_set_direction(__KEYBOARD_LOW_PORT_MASK__, GPIO_OUT); // define output 0x00F0
    //gpio_set_direction(__KEYBOARD_HIGH_PORT_MASK__, GPIO_IN); 
    previous_key = key =   __DEFAULT_VALUE__; //define default value 0xF
40000b9c:	e59f202c 	ldr	r2, [pc, #44]	; 40000bd0 <keyboard_init+0x48>
40000ba0:	e3a0300f 	mov	r3, #15	; 0xf
40000ba4:	e5c23000 	strb	r3, [r2]
40000ba8:	e59f3020 	ldr	r3, [pc, #32]	; 40000bd0 <keyboard_init+0x48>
40000bac:	e5d33000 	ldrb	r3, [r3]
40000bb0:	e59f201c 	ldr	r2, [pc, #28]	; 40000bd4 <keyboard_init+0x4c>
40000bb4:	e5c23000 	strb	r3, [r2]
    ptimer = timer;
40000bb8:	e59f2018 	ldr	r2, [pc, #24]	; 40000bd8 <keyboard_init+0x50>
40000bbc:	e51b3010 	ldr	r3, [fp, #-16]
40000bc0:	e5823000 	str	r3, [r2]
}
40000bc4:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000bc8:	e89d6800 	ldm	sp, {fp, sp, lr}
40000bcc:	e12fff1e 	bx	lr
40000bd0:	40001051 	.word	0x40001051
40000bd4:	40001050 	.word	0x40001050
40000bd8:	40001054 	.word	0x40001054

40000bdc <readNibble>:
 * 
 * @param[in]   inputMask:  mask of input port
 * @param[in]   outputMask: mask of output port
 * @param[out]  U8:         nibble read from the port
 * */
static U8 readNibble(U8 inputMask, U8 outputMask){
40000bdc:	e1a0c00d 	mov	ip, sp
40000be0:	e92dd800 	push	{fp, ip, lr, pc}
40000be4:	e24cb004 	sub	fp, ip, #4	; 0x4
40000be8:	e24dd010 	sub	sp, sp, #16	; 0x10
40000bec:	e1a03000 	mov	r3, r0
40000bf0:	e1a02001 	mov	r2, r1
40000bf4:	e54b3015 	strb	r3, [fp, #-21]
40000bf8:	e1a03002 	mov	r3, r2
40000bfc:	e54b3016 	strb	r3, [fp, #-22]
  U8 nibble;
 
  //Resistencias de Pull-Up
  gpio_set_direction(outputMask, GPIO_OUT);   // define output 0x00F0
40000c00:	e55b3016 	ldrb	r3, [fp, #-22]
40000c04:	e1a00003 	mov	r0, r3
40000c08:	e3a01001 	mov	r1, #1	; 0x1
40000c0c:	ebfffdf8 	bl	400003f4 <gpio_set_direction>
  gpio_set_direction(inputMask, GPIO_IN);     // define output 0x0F00
40000c10:	e55b3015 	ldrb	r3, [fp, #-21]
40000c14:	e1a00003 	mov	r0, r3
40000c18:	e3a01000 	mov	r1, #0	; 0x0
40000c1c:	ebfffdf4 	bl	400003f4 <gpio_set_direction>
  gpio_clear(outputMask);                      // 'Injecta' Zeros
40000c20:	e55b3016 	ldrb	r3, [fp, #-22]
40000c24:	e1a00003 	mov	r0, r3
40000c28:	ebfffe20 	bl	400004b0 <gpio_clear>
  
  nibble = gpio_read(inputMask);
40000c2c:	e55b3015 	ldrb	r3, [fp, #-21]
40000c30:	e1a00003 	mov	r0, r3
40000c34:	ebfffe2d 	bl	400004f0 <gpio_read>
40000c38:	e1a03000 	mov	r3, r0
40000c3c:	e54b300d 	strb	r3, [fp, #-13]
  timer_sleep_miliseconds(ptimer,10);         //Bounce
40000c40:	e59f3038 	ldr	r3, [pc, #56]	; 40000c80 <readNibble+0xa4>
40000c44:	e5933000 	ldr	r3, [r3]
40000c48:	e1a00003 	mov	r0, r3
40000c4c:	e3a01d9e 	mov	r1, #10112	; 0x2780
40000c50:	e2811030 	add	r1, r1, #48	; 0x30
40000c54:	ebfffd84 	bl	4000026c <timer_delay>
  
  return (nibble = gpio_read(inputMask));     //Há Tecla Pressionada!?  
40000c58:	e55b3015 	ldrb	r3, [fp, #-21]
40000c5c:	e1a00003 	mov	r0, r3
40000c60:	ebfffe22 	bl	400004f0 <gpio_read>
40000c64:	e1a03000 	mov	r3, r0
40000c68:	e54b300d 	strb	r3, [fp, #-13]
40000c6c:	e55b300d 	ldrb	r3, [fp, #-13]
}
40000c70:	e1a00003 	mov	r0, r3
40000c74:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000c78:	e89d6800 	ldm	sp, {fp, sp, lr}
40000c7c:	e12fff1e 	bx	lr
40000c80:	40001054 	.word	0x40001054

40000c84 <readKey>:
 * This funcion tries to read a key.
 * If no key is pressed or an error occurred while attempting to read the
 * keyboard, no valid value is affect. This means that call of the function
 * hasKey() will return the NO_KEY (0xFF)value.
 * */
void readKey(){
40000c84:	e1a0c00d 	mov	ip, sp
40000c88:	e92dd800 	push	{fp, ip, lr, pc}
40000c8c:	e24cb004 	sub	fp, ip, #4	; 0x4
40000c90:	e24dd008 	sub	sp, sp, #8	; 0x8
  U8 lowByteKey, highByteKey;
  U8 recentKey;

  //Read Lines
  lowByteKey = readNibble(__KEYBOARD_HIGH_PORT_MASK__,__KEYBOARD_LOW_PORT_MASK__ );
40000c94:	e3a00000 	mov	r0, #0	; 0x0
40000c98:	e3a010f0 	mov	r1, #240	; 0xf0
40000c9c:	ebffffce 	bl	40000bdc <readNibble>
40000ca0:	e1a03000 	mov	r3, r0
40000ca4:	e54b300f 	strb	r3, [fp, #-15]
  if (lowByteKey  == __DEFAULT_VALUE__ ){       //There is an key pressed!?
40000ca8:	e55b300f 	ldrb	r3, [fp, #-15]
40000cac:	e353000f 	cmp	r3, #15	; 0xf
40000cb0:	1a000003 	bne	40000cc4 <readKey+0x40>
    key = __NO_KEY__;  
40000cb4:	e59f30b8 	ldr	r3, [pc, #184]	; 40000d74 <readKey+0xf0>
40000cb8:	e3e02000 	mvn	r2, #0	; 0x0
40000cbc:	e5c32000 	strb	r2, [r3]
40000cc0:	ea000028 	b	40000d68 <readKey+0xe4>
    return;
  }

  //Read Columns
  highByteKey = readNibble(__KEYBOARD_LOW_PORT_MASK__,__KEYBOARD_HIGH_PORT_MASK__);
40000cc4:	e3a000f0 	mov	r0, #240	; 0xf0
40000cc8:	e3a01000 	mov	r1, #0	; 0x0
40000ccc:	ebffffc2 	bl	40000bdc <readNibble>
40000cd0:	e1a03000 	mov	r3, r0
40000cd4:	e54b300e 	strb	r3, [fp, #-14]
  if (highByteKey == __DEFAULT_VALUE__){       //Something went wrong, value discarted
40000cd8:	e55b300e 	ldrb	r3, [fp, #-14]
40000cdc:	e353000f 	cmp	r3, #15	; 0xf
40000ce0:	1a000003 	bne	40000cf4 <readKey+0x70>
    key = __NO_KEY__;
40000ce4:	e59f3088 	ldr	r3, [pc, #136]	; 40000d74 <readKey+0xf0>
40000ce8:	e3e02000 	mvn	r2, #0	; 0x0
40000cec:	e5c32000 	strb	r2, [r3]
40000cf0:	ea00001c 	b	40000d68 <readKey+0xe4>
    return; 
  }

  recentKey = (highByteKey<<__KEYBOARD_PORT_LOW_NIBBLE_SHIFT_MASK__) | lowByteKey;
40000cf4:	e55b300e 	ldrb	r3, [fp, #-14]
40000cf8:	e1a03203 	lsl	r3, r3, #4
40000cfc:	e20330ff 	and	r3, r3, #255	; 0xff
40000d00:	e55b200f 	ldrb	r2, [fp, #-15]
40000d04:	e1a01003 	mov	r1, r3
40000d08:	e1a03002 	mov	r3, r2
40000d0c:	e1813003 	orr	r3, r1, r3
40000d10:	e20330ff 	and	r3, r3, #255	; 0xff
40000d14:	e54b300d 	strb	r3, [fp, #-13]
  
  if (recentKey != key)  key  = recentKey;    //Save the bitmap
40000d18:	e59f3054 	ldr	r3, [pc, #84]	; 40000d74 <readKey+0xf0>
40000d1c:	e5d32000 	ldrb	r2, [r3]
40000d20:	e55b300d 	ldrb	r3, [fp, #-13]
40000d24:	e1530002 	cmp	r3, r2
40000d28:	0a000002 	beq	40000d38 <readKey+0xb4>
40000d2c:	e59f2040 	ldr	r2, [pc, #64]	; 40000d74 <readKey+0xf0>
40000d30:	e55b300d 	ldrb	r3, [fp, #-13]
40000d34:	e5c23000 	strb	r3, [r2]
  
  do{
    timer_sleep_miliseconds(ptimer,50);      //wait until the key is released
40000d38:	e59f3038 	ldr	r3, [pc, #56]	; 40000d78 <readKey+0xf4>
40000d3c:	e5933000 	ldr	r3, [r3]
40000d40:	e1a00003 	mov	r0, r3
40000d44:	e3a01cc6 	mov	r1, #50688	; 0xc600
40000d48:	e2811070 	add	r1, r1, #112	; 0x70
40000d4c:	ebfffd46 	bl	4000026c <timer_delay>
  }while((readNibble(__KEYBOARD_HIGH_PORT_MASK__,__KEYBOARD_LOW_PORT_MASK__ )) != __DEFAULT_VALUE__ );
40000d50:	e3a00000 	mov	r0, #0	; 0x0
40000d54:	e3a010f0 	mov	r1, #240	; 0xf0
40000d58:	ebffff9f 	bl	40000bdc <readNibble>
40000d5c:	e1a03000 	mov	r3, r0
40000d60:	e353000f 	cmp	r3, #15	; 0xf
40000d64:	1afffff3 	bne	40000d38 <readKey+0xb4>
  
}
40000d68:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000d6c:	e89d6800 	ldm	sp, {fp, sp, lr}
40000d70:	e12fff1e 	bx	lr
40000d74:	40001051 	.word	0x40001051
40000d78:	40001054 	.word	0x40001054

40000d7c <decodeKey>:
/**
 * Decode the bitmap to an valid key.
 * If simultaneos keys were pressed, returns the last valid combination
 * */
static U8 decodeKey(U8 keyBitmap){
40000d7c:	e1a0c00d 	mov	ip, sp
40000d80:	e92dd800 	push	{fp, ip, lr, pc}
40000d84:	e24cb004 	sub	fp, ip, #4	; 0x4
40000d88:	e24dd010 	sub	sp, sp, #16	; 0x10
40000d8c:	e1a03000 	mov	r3, r0
40000d90:	e54b300d 	strb	r3, [fp, #-13]
    register U8 colCount=0,lineCount=0;
40000d94:	e3a02000 	mov	r2, #0	; 0x0
40000d98:	e50b201c 	str	r2, [fp, #-28]
40000d9c:	e3a03000 	mov	r3, #0	; 0x0
40000da0:	e50b3018 	str	r3, [fp, #-24]
    register U8 nibble;
    
    nibble = keyBitmap & __KEYBOARD_MASK__;
40000da4:	e55b200d 	ldrb	r2, [fp, #-13]
40000da8:	e50b2014 	str	r2, [fp, #-20]
40000dac:	e51b3014 	ldr	r3, [fp, #-20]
40000db0:	e203300f 	and	r3, r3, #15	; 0xf
40000db4:	e50b3014 	str	r3, [fp, #-20]
40000db8:	ea000007 	b	40000ddc <decodeKey+0x60>
    for (;nibble;colCount++)
      nibble = nibble >> 1 ;
40000dbc:	e51b2014 	ldr	r2, [fp, #-20]
40000dc0:	e1a030a2 	lsr	r3, r2, #1
40000dc4:	e20330ff 	and	r3, r3, #255	; 0xff
40000dc8:	e50b3014 	str	r3, [fp, #-20]
static U8 decodeKey(U8 keyBitmap){
    register U8 colCount=0,lineCount=0;
    register U8 nibble;
    
    nibble = keyBitmap & __KEYBOARD_MASK__;
    for (;nibble;colCount++)
40000dcc:	e51b201c 	ldr	r2, [fp, #-28]
40000dd0:	e2823001 	add	r3, r2, #1	; 0x1
40000dd4:	e20330ff 	and	r3, r3, #255	; 0xff
40000dd8:	e50b301c 	str	r3, [fp, #-28]
40000ddc:	e51b3014 	ldr	r3, [fp, #-20]
40000de0:	e3530000 	cmp	r3, #0	; 0x0
40000de4:	1afffff4 	bne	40000dbc <decodeKey+0x40>
      nibble = nibble >> 1 ;
    
    nibble = (keyBitmap >> __KEYBOARD_PORT_LOW_NIBBLE_SHIFT_MASK__) & __KEYBOARD_MASK__;
40000de8:	e55b300d 	ldrb	r3, [fp, #-13]
40000dec:	e1a03223 	lsr	r3, r3, #4
40000df0:	e20330ff 	and	r3, r3, #255	; 0xff
40000df4:	e50b3014 	str	r3, [fp, #-20]
40000df8:	ea000007 	b	40000e1c <decodeKey+0xa0>
    for (;nibble;lineCount++)
      nibble = nibble >> 1 ; 
40000dfc:	e51b2014 	ldr	r2, [fp, #-20]
40000e00:	e1a030a2 	lsr	r3, r2, #1
40000e04:	e20330ff 	and	r3, r3, #255	; 0xff
40000e08:	e50b3014 	str	r3, [fp, #-20]
    nibble = keyBitmap & __KEYBOARD_MASK__;
    for (;nibble;colCount++)
      nibble = nibble >> 1 ;
    
    nibble = (keyBitmap >> __KEYBOARD_PORT_LOW_NIBBLE_SHIFT_MASK__) & __KEYBOARD_MASK__;
    for (;nibble;lineCount++)
40000e0c:	e51b2018 	ldr	r2, [fp, #-24]
40000e10:	e2823001 	add	r3, r2, #1	; 0x1
40000e14:	e20330ff 	and	r3, r3, #255	; 0xff
40000e18:	e50b3018 	str	r3, [fp, #-24]
40000e1c:	e51b3014 	ldr	r3, [fp, #-20]
40000e20:	e3530000 	cmp	r3, #0	; 0x0
40000e24:	1afffff4 	bne	40000dfc <decodeKey+0x80>
      nibble = nibble >> 1 ; 
      
    colCount--;lineCount--;
40000e28:	e51b201c 	ldr	r2, [fp, #-28]
40000e2c:	e2423001 	sub	r3, r2, #1	; 0x1
40000e30:	e20330ff 	and	r3, r3, #255	; 0xff
40000e34:	e50b301c 	str	r3, [fp, #-28]
40000e38:	e51b2018 	ldr	r2, [fp, #-24]
40000e3c:	e2423001 	sub	r3, r2, #1	; 0x1
40000e40:	e20330ff 	and	r3, r3, #255	; 0xff
40000e44:	e50b3018 	str	r3, [fp, #-24]
    return (U8)((lineCount << 2) | colCount);
40000e48:	e51b3018 	ldr	r3, [fp, #-24]
40000e4c:	e1a03103 	lsl	r3, r3, #2
40000e50:	e20330ff 	and	r3, r3, #255	; 0xff
40000e54:	e51b201c 	ldr	r2, [fp, #-28]
40000e58:	e1a01003 	mov	r1, r3
40000e5c:	e1a03002 	mov	r3, r2
40000e60:	e1813003 	orr	r3, r1, r3
40000e64:	e20330ff 	and	r3, r3, #255	; 0xff
40000e68:	e20330ff 	and	r3, r3, #255	; 0xff
}
40000e6c:	e1a00003 	mov	r0, r3
40000e70:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000e74:	e89d6800 	ldm	sp, {fp, sp, lr}
40000e78:	e12fff1e 	bx	lr

40000e7c <hasKey>:

/**
 * Check if it is an valid key stored from an previous call to read.
 * returns 0 if there is no Key, otherwise if there is.
 * */
U8 hasKey(){ return (key == __NO_KEY__); }
40000e7c:	e1a0c00d 	mov	ip, sp
40000e80:	e92dd800 	push	{fp, ip, lr, pc}
40000e84:	e24cb004 	sub	fp, ip, #4	; 0x4
40000e88:	e59f301c 	ldr	r3, [pc, #28]	; 40000eac <hasKey+0x30>
40000e8c:	e5d33000 	ldrb	r3, [r3]
40000e90:	e35300ff 	cmp	r3, #255	; 0xff
40000e94:	13a03000 	movne	r3, #0	; 0x0
40000e98:	03a03001 	moveq	r3, #1	; 0x1
40000e9c:	e1a00003 	mov	r0, r3
40000ea0:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000ea4:	e89d6800 	ldm	sp, {fp, sp, lr}
40000ea8:	e12fff1e 	bx	lr
40000eac:	40001051 	.word	0x40001051

40000eb0 <getKey>:
 * Return the key read in the last call of readKey.
 * Should be a previous call to hasKey for best practice.
 * 
 * Returns the key read or NO_KEY if else
 * */
U8 getKey(){
40000eb0:	e1a0c00d 	mov	ip, sp
40000eb4:	e92dd800 	push	{fp, ip, lr, pc}
40000eb8:	e24cb004 	sub	fp, ip, #4	; 0x4
40000ebc:	e24dd010 	sub	sp, sp, #16	; 0x10
  U8 keyBitMap = key;
40000ec0:	e59f3064 	ldr	r3, [pc, #100]	; 40000f2c <getKey+0x7c>
40000ec4:	e5d33000 	ldrb	r3, [r3]
40000ec8:	e54b300d 	strb	r3, [fp, #-13]
  if (key == __NO_KEY__)  return __NO_KEY__;
40000ecc:	e59f3058 	ldr	r3, [pc, #88]	; 40000f2c <getKey+0x7c>
40000ed0:	e5d33000 	ldrb	r3, [r3]
40000ed4:	e35300ff 	cmp	r3, #255	; 0xff
40000ed8:	1a000002 	bne	40000ee8 <getKey+0x38>
40000edc:	e3a030ff 	mov	r3, #255	; 0xff
40000ee0:	e50b3018 	str	r3, [fp, #-24]
40000ee4:	ea00000b 	b	40000f18 <getKey+0x68>
  previous_key = key;
40000ee8:	e59f303c 	ldr	r3, [pc, #60]	; 40000f2c <getKey+0x7c>
40000eec:	e5d33000 	ldrb	r3, [r3]
40000ef0:	e59f2038 	ldr	r2, [pc, #56]	; 40000f30 <getKey+0x80>
40000ef4:	e5c23000 	strb	r3, [r2]
  key = __NO_KEY__;
40000ef8:	e59f202c 	ldr	r2, [pc, #44]	; 40000f2c <getKey+0x7c>
40000efc:	e3e03000 	mvn	r3, #0	; 0x0
40000f00:	e5c23000 	strb	r3, [r2]
  return decodeKey(keyBitMap);  
40000f04:	e55b300d 	ldrb	r3, [fp, #-13]
40000f08:	e1a00003 	mov	r0, r3
40000f0c:	ebffff9a 	bl	40000d7c <decodeKey>
40000f10:	e1a03000 	mov	r3, r0
40000f14:	e50b3018 	str	r3, [fp, #-24]
40000f18:	e51b3018 	ldr	r3, [fp, #-24]
}
40000f1c:	e1a00003 	mov	r0, r3
40000f20:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000f24:	e89d6800 	ldm	sp, {fp, sp, lr}
40000f28:	e12fff1e 	bx	lr
40000f2c:	40001051 	.word	0x40001051
40000f30:	40001050 	.word	0x40001050

40000f34 <getPreviousKey>:
/**
 * Returns the previous key pressed ou NO_KEY if else 
 * */
U8 getPreviousKey(){ 
40000f34:	e1a0c00d 	mov	ip, sp
40000f38:	e92dd800 	push	{fp, ip, lr, pc}
40000f3c:	e24cb004 	sub	fp, ip, #4	; 0x4
40000f40:	e24dd008 	sub	sp, sp, #8	; 0x8
  if (previous_key == __NO_KEY__)  return __NO_KEY__;
40000f44:	e59f3040 	ldr	r3, [pc, #64]	; 40000f8c <getPreviousKey+0x58>
40000f48:	e5d33000 	ldrb	r3, [r3]
40000f4c:	e35300ff 	cmp	r3, #255	; 0xff
40000f50:	1a000002 	bne	40000f60 <getPreviousKey+0x2c>
40000f54:	e3a030ff 	mov	r3, #255	; 0xff
40000f58:	e50b3010 	str	r3, [fp, #-16]
40000f5c:	ea000005 	b	40000f78 <getPreviousKey+0x44>
  return decodeKey(previous_key);
40000f60:	e59f3024 	ldr	r3, [pc, #36]	; 40000f8c <getPreviousKey+0x58>
40000f64:	e5d33000 	ldrb	r3, [r3]
40000f68:	e1a00003 	mov	r0, r3
40000f6c:	ebffff82 	bl	40000d7c <decodeKey>
40000f70:	e1a03000 	mov	r3, r0
40000f74:	e50b3010 	str	r3, [fp, #-16]
40000f78:	e51b3010 	ldr	r3, [fp, #-16]
}
40000f7c:	e1a00003 	mov	r0, r3
40000f80:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000f84:	e89d6800 	ldm	sp, {fp, sp, lr}
40000f88:	e12fff1e 	bx	lr
40000f8c:	40001050 	.word	0x40001050

40000f90 <clearKey>:


/**
 * Clears the values of both stored keys
 * */
void clearKey(){previous_key = key = __NO_KEY__;}
40000f90:	e1a0c00d 	mov	ip, sp
40000f94:	e92dd800 	push	{fp, ip, lr, pc}
40000f98:	e24cb004 	sub	fp, ip, #4	; 0x4
40000f9c:	e59f2020 	ldr	r2, [pc, #32]	; 40000fc4 <clearKey+0x34>
40000fa0:	e3e03000 	mvn	r3, #0	; 0x0
40000fa4:	e5c23000 	strb	r3, [r2]
40000fa8:	e59f3014 	ldr	r3, [pc, #20]	; 40000fc4 <clearKey+0x34>
40000fac:	e5d33000 	ldrb	r3, [r3]
40000fb0:	e59f2010 	ldr	r2, [pc, #16]	; 40000fc8 <clearKey+0x38>
40000fb4:	e5c23000 	strb	r3, [r2]
40000fb8:	e24bd00c 	sub	sp, fp, #12	; 0xc
40000fbc:	e89d6800 	ldm	sp, {fp, sp, lr}
40000fc0:	e12fff1e 	bx	lr
40000fc4:	40001051 	.word	0x40001051
40000fc8:	40001050 	.word	0x40001050

40000fcc <main>:
#include "TYPES.h"
#include "startosc.h"

#define  LCD_MASK   ((U32) 0x7F00)

int main(){
40000fcc:	e1a0c00d 	mov	ip, sp
40000fd0:	e92dd800 	push	{fp, ip, lr, pc}
40000fd4:	e24cb004 	sub	fp, ip, #4	; 0x4
40000fd8:	e24dd008 	sub	sp, sp, #8	; 0x8
  gpio_init(0,0);
40000fdc:	e3a00000 	mov	r0, #0	; 0x0
40000fe0:	e3a01000 	mov	r1, #0	; 0x0
40000fe4:	ebfffcd8 	bl	4000034c <gpio_init>
  
  //gpio_set_direction(0x1F00,GPIO_OUT);
  //gpio_clear(0x1F00,0x1F00);
  //gpio_set(0x1F00);
  timer_init(pTIMER0,58982400/MICRO);
40000fe8:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
40000fec:	e2800901 	add	r0, r0, #16384	; 0x4000
40000ff0:	e3a0103a 	mov	r1, #58	; 0x3a
40000ff4:	ebfffc87 	bl	40000218 <timer_init>
  LCD_init(pTIMER0);
40000ff8:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
40000ffc:	e2800901 	add	r0, r0, #16384	; 0x4000
40001000:	ebfffda7 	bl	400006a4 <LCD_init>
  keyboard_init(pTIMER0);
40001004:	e3a0020e 	mov	r0, #-536870912	; 0xe0000000
40001008:	e2800901 	add	r0, r0, #16384	; 0x4000
4000100c:	ebfffedd 	bl	40000b88 <keyboard_init>
    timer_sleep_miliseconds(pTIMER0,500);
  }
   */

  while(1){
	int key= NO_KEY;
40001010:	e3a030ff 	mov	r3, #255	; 0xff
40001014:	e50b3010 	str	r3, [fp, #-16]
40001018:	ea000000 	b	40001020 <main+0x54>
	while(!hasKey()){
		readKey();
4000101c:	ebffff18 	bl	40000c84 <readKey>
  }
   */

  while(1){
	int key= NO_KEY;
	while(!hasKey()){
40001020:	ebffff95 	bl	40000e7c <hasKey>
40001024:	e1a03000 	mov	r3, r0
40001028:	e3530000 	cmp	r3, #0	; 0x0
4000102c:	0afffffa 	beq	4000101c <main+0x50>
		readKey();
	};
	key = getKey();
40001030:	ebffff9e 	bl	40000eb0 <getKey>
40001034:	e1a03000 	mov	r3, r0
40001038:	e50b3010 	str	r3, [fp, #-16]
	writeString(key);
4000103c:	e51b3010 	ldr	r3, [fp, #-16]
40001040:	e1a00003 	mov	r0, r3
40001044:	ebfffe65 	bl	400009e0 <writeString>
40001048:	eafffff0 	b	40001010 <main+0x44>
